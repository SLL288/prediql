[
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      type\n      identifier\n      description {\n        name\n        languageCode\n      }\n    }\n  }\n}\n",
      "vulnerability_type": "basic_call"
    },
    "response_status": 200,
    "request_time_seconds": 1.072,
    "timestamp": "2025-10-01T21:05:56.163523Z",
    "count": 1,
    "vulnerability_type": "basic_call",
    "response_body": {
      "data": {
        "topLevelDocumentaryUnits": {
          "items": [
            {
              "id": "at-006597-01",
              "type": "DocumentaryUnit",
              "identifier": "006597-01",
              "description": {
                "name": "Memorbuch - Juden in St. P\u00f6lten",
                "languageCode": "eng"
              }
            }
          ]
        }
      }
    },
    "success": true,
    "negative_success": false
  },
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      description {\n        name\n        languageCode\n        archivistNote\n        scopeAndContent\n      }\n      repository {\n        description {\n          history\n        }\n      }\n    }\n  }\n}\n# Explanation: We target string fields within nested objects. If the backend constructs SQL queries from these fields without proper sanitization, an injection via these fields could occur. The actual payload would typically be in an argument, but since `topLevelDocumentaryUnits` doesn't take filtering arguments directly on descriptive fields, a more indirect approach is needed. In a real scenario, we'd look for arguments like `where` or `filter` that directly map to database columns. This query explores if the *content* of returned data might be processed insecurely.\n",
      "vulnerability_type": "sql_injection"
    },
    "response_status": 200,
    "request_time_seconds": 0.933,
    "timestamp": "2025-10-01T21:06:00.101061Z",
    "count": 2,
    "vulnerability_type": "sql_injection",
    "response_body": {
      "data": {
        "topLevelDocumentaryUnits": {
          "items": [
            {
              "id": "at-006597-01",
              "description": {
                "name": "Memorbuch - Juden in St. P\u00f6lten",
                "languageCode": "eng",
                "archivistNote": "Information supplied by INJOEST on 20.09.2023",
                "scopeAndContent": null
              },
              "repository": {
                "description": {
                  "history": "The Institute for Jewish History in Austria was founded in 1988 and is housed in the former synagogue of St. P\u00f6lten 60 kilometers west of Vienna. Its task is to carry out comprehensive research into the history and culture of the Jews in Austria, from the Middle Ages up to the present day.  It is our aim to counteract anti- and philo-Semitic prejudices and incorrect information through academic research, publications, lectures and activities in the area of adult education and school projects. The location of the Institute in the former synagogue in St. Poelten gave a new and meaningful use to this abandoned building."
                }
              }
            }
          ]
        }
      }
    },
    "success": true,
    "negative_success": false
  },
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      description {\n        name\n        archivistNote\n        scopeAndContent\n        acquisition\n      }\n    }\n  }\n}\n# Explanation: Similar to SQL injection, we're targeting string fields that might be displayed in a web interface without proper output encoding. The injection itself would occur if a malicious value like \"<script>alert('XSS')</script>\" was *pre-inserted* into one of these fields (e.g., archivistNote, scopeAndContent) via another API call or data import. This query checks if those fields are retrievable. In a direct input scenario, we'd look for arguments that accept user-controlled strings.\n",
      "vulnerability_type": "xss_injection"
    },
    "response_status": 200,
    "request_time_seconds": 1.481,
    "timestamp": "2025-10-01T21:06:03.436282Z",
    "count": 3,
    "vulnerability_type": "xss_injection",
    "response_body": {
      "data": {
        "topLevelDocumentaryUnits": {
          "items": [
            {
              "id": "at-006597-01",
              "description": {
                "name": "Memorbuch - Juden in St. P\u00f6lten",
                "archivistNote": "Information supplied by INJOEST on 20.09.2023",
                "scopeAndContent": null,
                "acquisition": null
              }
            }
          ]
        }
      }
    },
    "success": true,
    "negative_success": false
  },
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      otherIdentifiers\n      repository {\n        links {\n          targets {\n            ... on Repository { id }\n            ... on DocumentaryUnit { id }\n          }\n        }\n      }\n    }\n  }\n}\n# Explanation: SSRF typically involves an endpoint that fetches data from a URL provided by the user. The `Link` type with its `targets` field, and the conceptual \"otherIdentifiers\" could potentially be used to store or process external references. If `otherIdentifiers` or any field within `Link` or `RepositoryDescription` (like `webpage` in `Address`) could be set to a URL and then the server attempts to fetch from it, SSRF is possible. Without direct URL arguments in `topLevelDocumentaryUnits`, this query explores fields that *might* indirectly trigger SSRF if their values are used in backend HTTP requests.\n",
      "vulnerability_type": "ssrf_injection"
    },
    "response_status": 200,
    "request_time_seconds": 1.551,
    "timestamp": "2025-10-01T21:06:07.510847Z",
    "count": 4,
    "vulnerability_type": "ssrf_injection",
    "response_body": {
      "data": {
        "topLevelDocumentaryUnits": {
          "items": [
            {
              "id": "at-006597-01",
              "otherIdentifiers": [],
              "repository": {
                "links": []
              }
            }
          ]
        }
      }
    },
    "success": true,
    "negative_success": false
  },
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      description {\n        name\n        archivistNote\n        scopeAndContent\n      }\n    }\n  }\n}\n# Explanation: Similar to XSS and SQL injection, OS command injection relies on user-supplied input being executed by the server. Without an explicit argument where a command could be injected (e.g., a \"filename\" or \"path\" argument), we're again relying on the possibility that data retrieved from string fields like `archivistNote` or `scopeAndContent` might be passed to a system command. This query checks if these fields are accessible.\n",
      "vulnerability_type": "os_command_injection"
    },
    "response_status": 200,
    "request_time_seconds": 0.932,
    "timestamp": "2025-10-01T21:06:10.807433Z",
    "count": 5,
    "vulnerability_type": "os_command_injection",
    "response_body": {
      "data": {
        "topLevelDocumentaryUnits": {
          "items": [
            {
              "id": "at-006597-01",
              "description": {
                "name": "Memorbuch - Juden in St. P\u00f6lten",
                "archivistNote": "Information supplied by INJOEST on 20.09.2023",
                "scopeAndContent": null
              }
            }
          ]
        }
      }
    },
    "success": true,
    "negative_success": false
  },
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      otherIdentifiers\n      description {\n        name\n        archivalHistory\n      }\n    }\n  }\n}\n# Explanation: Path injection usually occurs when user input is used to construct a file path. Like other injections, `topLevelDocumentaryUnits` doesn't expose arguments directly for this. We are inspecting string fields (`otherIdentifiers`, `archivalHistory`) that might *contain* path-like strings which, if later used in file operations, could lead to path traversal.\n",
      "vulnerability_type": "path_injection"
    },
    "response_status": 200,
    "request_time_seconds": 1.019,
    "timestamp": "2025-10-01T21:06:13.445634Z",
    "count": 6,
    "vulnerability_type": "path_injection",
    "response_body": {
      "data": {
        "topLevelDocumentaryUnits": {
          "items": [
            {
              "id": "at-006597-01",
              "otherIdentifiers": [],
              "description": {
                "name": "Memorbuch - Juden in St. P\u00f6lten",
                "archivalHistory": null
              }
            }
          ]
        }
      }
    },
    "success": true,
    "negative_success": false
  },
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      description {\n        name\n        archivistNote\n        scopeAndContent\n        acquisition\n      }\n    }\n  }\n}\n# Explanation: HTML Injection is a variant of XSS where the goal is to inject raw HTML rather than JavaScript. The same string fields (`archivistNote`, `scopeAndContent`, `acquisition`) that might be vulnerable to XSS in a web display context could also be vulnerable to HTML injection if user-provided HTML is not sanitized.\n",
      "vulnerability_type": "html_injection"
    },
    "response_status": 200,
    "request_time_seconds": 2.879,
    "timestamp": "2025-10-01T21:06:19.262420Z",
    "count": 7,
    "vulnerability_type": "html_injection",
    "response_body": {
      "data": {
        "topLevelDocumentaryUnits": {
          "items": [
            {
              "id": "at-006597-01",
              "description": {
                "name": "Memorbuch - Juden in St. P\u00f6lten",
                "archivistNote": "Information supplied by INJOEST on 20.09.2023",
                "scopeAndContent": null,
                "acquisition": null
              }
            }
          ]
        }
      }
    },
    "success": true,
    "negative_success": false
  },
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      type\n    }\n  }\n}\n",
      "vulnerability_type": "query_deny_bypass_non_aliased"
    },
    "query_deny_bypass_responses": {
      "non_aliased": {
        "response_status": 200,
        "request_time_seconds": 1.399,
        "timestamp": "2025-10-01T21:06:23.548265Z",
        "response_body": {
          "data": {
            "topLevelDocumentaryUnits": {
              "items": [
                {
                  "id": "at-006597-01",
                  "type": "DocumentaryUnit"
                }
              ]
            }
          }
        }
      },
      "aliased": {
        "response_status": 200,
        "request_time_seconds": 2.535,
        "timestamp": "2025-10-01T21:06:26.083638Z",
        "response_body": {
          "data": {
            "s": {
              "items": [
                {
                  "id": "at-006597-01",
                  "type": "DocumentaryUnit"
                }
              ]
            }
          }
        }
      }
    },
    "vulnerability_type": "query_deny_bypass",
    "count": 8,
    "timestamp": "2025-10-01T21:06:26.083766Z",
    "success": false,
    "negative_success": false,
    "retry_query": "\n    query {\n      episodesByIds(ids: [1]) {\n        id\n        name\n      }\n    }\n    ",
    "retry_status": 400,
    "retry_time_seconds": 0.54,
    "retry_response_body": {
      "errors": [
        {
          "message": "Validation error (FieldUndefined@[episodesByIds]) : Field 'episodesByIds' in type 'Root' is undefined",
          "locations": [
            {
              "line": 3,
              "column": 7
            }
          ],
          "extensions": {
            "classification": "ValidationError"
          }
        }
      ]
    }
  },
  {
    "query": {
      "query": "\nquery BypassQuery {\n  s: topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      type\n    }\n  }\n}\n",
      "vulnerability_type": "query_deny_bypass_aliased"
    },
    "query_deny_bypass_responses": {
      "non_aliased": {
        "response_status": 200,
        "request_time_seconds": 0.885,
        "timestamp": "2025-10-01T21:06:30.351696Z",
        "response_body": {
          "data": {
            "topLevelDocumentaryUnits": {
              "items": [
                {
                  "id": "at-006597-01",
                  "type": "DocumentaryUnit"
                }
              ]
            }
          }
        }
      },
      "aliased": {
        "response_status": 200,
        "request_time_seconds": 0.962,
        "timestamp": "2025-10-01T21:06:31.313881Z",
        "response_body": {
          "data": {
            "s": {
              "items": [
                {
                  "id": "at-006597-01",
                  "type": "DocumentaryUnit"
                }
              ]
            }
          }
        }
      }
    },
    "vulnerability_type": "query_deny_bypass",
    "count": 9,
    "timestamp": "2025-10-01T21:06:31.313948Z",
    "success": false,
    "negative_success": false,
    "retry_query": "\n    query {\n      episodesByIds(ids: [1]) {\n        id\n        name\n      }\n    }\n    ",
    "retry_status": 400,
    "retry_time_seconds": 0.488,
    "retry_response_body": {
      "errors": [
        {
          "message": "Validation error (FieldUndefined@[episodesByIds]) : Field 'episodesByIds' in type 'Root' is undefined",
          "locations": [
            {
              "line": 3,
              "column": 7
            }
          ],
          "extensions": {
            "classification": "ValidationError"
          }
        }
      ]
    }
  },
  {
    "query": {
      "query": "\nquery IntrospectionQuery {\n  topLevelDocumentaryUnits {\n    queryType {\n      name\n    }\n    types {\n      kind\n      name\n      fields(includeDeprecated: true) {\n        name\n        type {\n          name\n          kind\n        }\n      }\n    }\n  }\n}\n",
      "vulnerability_type": "introspection"
    },
    "response_status": 400,
    "request_time_seconds": 0.505,
    "timestamp": "2025-10-01T21:06:34.988204Z",
    "count": 10,
    "vulnerability_type": "introspection",
    "response_body": {
      "errors": [
        {
          "message": "Validation error (FieldUndefined@[topLevelDocumentaryUnits/queryType]) : Field 'queryType' in type 'documentaryUnits' is undefined",
          "locations": [
            {
              "line": 4,
              "column": 5
            }
          ],
          "extensions": {
            "classification": "ValidationError"
          }
        },
        {
          "message": "Validation error (FieldUndefined@[topLevelDocumentaryUnits/types]) : Field 'types' in type 'documentaryUnits' is undefined",
          "locations": [
            {
              "line": 7,
              "column": 5
            }
          ],
          "extensions": {
            "classification": "ValidationError"
          }
        }
      ]
    },
    "success": false,
    "negative_success": false
  },
  {
    "query": {
      "query": "\nquery {\n  topLevelDocumentaryUnits(first: 1) {\n    items {\n      id\n      description {\n        name_\n      }\n    }\n  }\n}\n",
      "vulnerability_type": "field_suggestions"
    },
    "response_status": 400,
    "request_time_seconds": 7.491,
    "timestamp": "2025-10-01T21:06:45.258496Z",
    "count": 11,
    "vulnerability_type": "field_suggestions",
    "response_body": {
      "errors": [
        {
          "message": "Validation error (FieldUndefined@[topLevelDocumentaryUnits/items/description/name_]) : Field 'name_' in type 'DocumentaryUnitDescription' is undefined",
          "locations": [
            {
              "line": 7,
              "column": 9
            }
          ],
          "extensions": {
            "classification": "ValidationError"
          }
        }
      ]
    },
    "success": false,
    "negative_success": false
  }
]