timestamp,node_name,response_status,simple_count,llm_count,agreement_score,consensus,common_categories,simple_unique,llm_unique,simple_vulnerable_count,simple_potential_count,simple_safe_count,llm_vulnerable_count,llm_potential_count,llm_safe_count,potential_agreement_score,potential_consensus,common_potential_categories,simple_unique_potential,llm_unique_potential,simple_results,llm_results
2025-10-03T08:27:16.940228,updatePost_response_1,200,1,0,0.0,simple_only,,Injection Attacks,,0,1,0,0,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""SQL Injection (SQLi) Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""SQL injection vulnerability detected - malicious SQL patterns found in response"", ""evidence"": ""Response status: 200, SQL patterns detected in response""}]",[]
2025-10-03T08:27:31.177154,updatePost_response_2,200,1,1,1.0,both_detected,Injection Attacks,,,0,1,0,1,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""Cross-Site Scripting (XSS) Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""XSS injection vulnerability detected - malicious script patterns found in response"", ""evidence"": ""Response status: 200, XSS patterns detected in response data""}]","[{""detection_name"": ""LLM: xss_injection"", ""detection"": ""vulnerable"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response for updatePost returns the 'body' field containing raw script tags: <script>alert('XSS from body')</script>. This is direct evidence that user-controlled HTML/JS is being stored and/or reflected by the API without being sanitized or encoded. If a web client or any downstream consumer injects this value into a page DOM without proper escaping, it will execute as JavaScript (stored/reflected XSS). The context (a post body) strongly suggests this is user-editable content and thus represents a stored XSS risk. False positives are possible if all clients always HTML-encode/escape this field or render it in a non-HTML context (e.g., as plain text in a JSON consumer), but given the presence of script tags in the API response itself, this is a high-risk finding. Recommended mitigations: validate/encode output on the server and escape HTML on rendering, strip or sanitize dangerous tags/attributes on input (server-side), apply Content Security Policy (CSP), and use appropriate contextual encoding when inserting into HTML."", ""evidence"": ""\""body\"": \""<script>alert('XSS from body')</script>\"""", ""confidence"": 0.9, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""xss_injection"", ""severity"": ""HIGH"", ""confidence"": 0.9, ""evidence"": ""\""body\"": \""<script>alert('XSS from body')</script>\"""", ""explanation"": ""The GraphQL response for updatePost returns the 'body' field containing raw script tags: <script>alert('XSS from body')</script>. This is direct evidence that user-controlled HTML/JS is being stored and/or reflected by the API without being sanitized or encoded. If a web client or any downstream consumer injects this value into a page DOM without proper escaping, it will execute as JavaScript (stored/reflected XSS). The context (a post body) strongly suggests this is user-editable content and thus represents a stored XSS risk. False positives are possible if all clients always HTML-encode/escape this field or render it in a non-HTML context (e.g., as plain text in a JSON consumer), but given the presence of script tags in the API response itself, this is a high-risk finding. Recommended mitigations: validate/encode output on the server and escape HTML on rendering, strip or sanitize dangerous tags/attributes on input (server-side), apply Content Security Policy (CSP), and use appropriate contextual encoding when inserting into HTML.""}}]"
2025-10-03T08:27:45.878761,updatePost_response_3,200,1,0,0.0,simple_only,,Injection Attacks,,0,1,0,0,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""Server-Side Request Forgery (SSRF) Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""SSRF injection vulnerability detected - internal network access patterns found"", ""evidence"": ""Response status: 200, SSRF keywords detected in response""}]",[]
2025-10-03T08:28:02.889933,updatePost_response_4,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-03T08:28:16.060191,updatePost_response_5,200,1,0,0.0,simple_only,,Injection Attacks,,0,1,0,0,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""Path Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""Path injection vulnerability detected - file system access patterns found"", ""evidence"": ""Response status: 200, Path injection patterns detected in response""}]",[]
2025-10-03T08:28:24.189492,updatePost_response_6,200,1,1,1.0,both_detected,Injection Attacks,,,0,1,0,1,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""HTML Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""HTML injection vulnerability detected - HTML markup found in response"", ""evidence"": ""Response status: 200, HTML patterns detected in response data""}]","[{""detection_name"": ""LLM: html_injection"", ""detection"": ""vulnerable"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response returns raw HTML markup with JavaScript event handlers in user-controllable fields (title and body). That indicates the API accepts and echoes/stores HTML/JS without sanitization. If a web client renders these values into the DOM without proper escaping or sanitization, this will result in stored XSS (HTML injection) and can lead to arbitrary script execution in other users' browsers. While the response alone does not prove a successful client-side execution (depends on how clients handle these fields), the presence of <img> with onerror and a <div> with onclick demonstrates a clear injection vector. Recommend treating this as a high-risk issue, validating/escaping or sanitizing HTML on input/output, or enforcing an allowlist and content-type restrictions."", ""evidence"": ""Response contains unescaped HTML/JS in fields: title=\""<img src=x onerror=\\\""alert('html')\\\"">\"", body=\""<div onclick=\\\""alert('injected')\\\"">Click me</div>\"""", ""confidence"": 0.9, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""html_injection"", ""severity"": ""HIGH"", ""confidence"": 0.9, ""evidence"": ""Response contains unescaped HTML/JS in fields: title=\""<img src=x onerror=\\\""alert('html')\\\"">\"", body=\""<div onclick=\\\""alert('injected')\\\"">Click me</div>\"""", ""explanation"": ""The GraphQL response returns raw HTML markup with JavaScript event handlers in user-controllable fields (title and body). That indicates the API accepts and echoes/stores HTML/JS without sanitization. If a web client renders these values into the DOM without proper escaping or sanitization, this will result in stored XSS (HTML injection) and can lead to arbitrary script execution in other users' browsers. While the response alone does not prove a successful client-side execution (depends on how clients handle these fields), the presence of <img> with onerror and a <div> with onclick demonstrates a clear injection vector. Recommend treating this as a high-risk issue, validating/escaping or sanitizing HTML on input/output, or enforcing an allowlist and content-type restrictions.""}}]"
2025-10-03T08:28:31.514093,updatePost_response_7,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-03T08:28:38.514084,updatePost_response_8,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-03T08:28:49.478000,updatePost_response_9,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-03T08:29:05.040203,updatePost_response_10,400,1,1,0.0,both_detected,,Information Disclosure,Unknown,1,0,0,0,0,1,0.0,no_potential,,,,"[{""detection_name"": ""Field Suggestions Enabled"", ""detection"": ""vulnerable"", ""category"": ""Information Disclosure"", ""description"": ""Field suggestions enabled - potential information disclosure"", ""evidence"": ""Found \""did you mean\"" in error message - field suggestions are enabled""}]","[{""detection_name"": ""LLM: field_suggestions"", ""detection"": ""safe"", ""category"": ""Unknown"", ""description"": ""The GraphQL error responses include 'Did you mean ...?' suggestions that reveal exact field names on the Post type (e.g., title, body, id, user). This is a field_suggestions information-disclosure issue: by returning alternative field names in validation errors the API leaks schema details that can aid attackers in enumerating the schema and crafting targeted queries. While this does not directly execute commands or expose sensitive data, it reduces the effort required to probe and exploit the API. Mitigation: suppress or genericize validation error details in production (avoid returning suggested field names), or require authentication/authorization for schema-introspection-like behaviors."", ""evidence"": ""Errors containing suggestions: \""Cannot query field \\\""titel\\\"" on type \\\""Post\\\"". Did you mean \\\""title\\\""?\"", \""Cannot query field \\\""bdy\\\"" on type \\\""Post\\\"". Did you mean \\\""body\\\"" or \\\""id\\\""?\"", \""Cannot query field \\\""usr\\\"" on type \\\""Post\\\"". Did you mean \\\""user\\\""?\"""", ""confidence"": 0.9, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""field_suggestions"", ""severity"": ""LOW"", ""confidence"": 0.9, ""evidence"": ""Errors containing suggestions: \""Cannot query field \\\""titel\\\"" on type \\\""Post\\\"". Did you mean \\\""title\\\""?\"", \""Cannot query field \\\""bdy\\\"" on type \\\""Post\\\"". Did you mean \\\""body\\\"" or \\\""id\\\""?\"", \""Cannot query field \\\""usr\\\"" on type \\\""Post\\\"". Did you mean \\\""user\\\""?\"""", ""explanation"": ""The GraphQL error responses include 'Did you mean ...?' suggestions that reveal exact field names on the Post type (e.g., title, body, id, user). This is a field_suggestions information-disclosure issue: by returning alternative field names in validation errors the API leaks schema details that can aid attackers in enumerating the schema and crafting targeted queries. While this does not directly execute commands or expose sensitive data, it reduces the effort required to probe and exploit the API. Mitigation: suppress or genericize validation error details in production (avoid returning suggested field names), or require authentication/authorization for schema-introspection-like behaviors.""}}]"
