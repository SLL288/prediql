timestamp,node_name,response_status,simple_count,llm_count,agreement_score,consensus,common_categories,simple_unique,llm_unique,simple_vulnerable_count,simple_potential_count,simple_safe_count,llm_vulnerable_count,llm_potential_count,llm_safe_count,potential_agreement_score,potential_consensus,common_potential_categories,simple_unique_potential,llm_unique_potential,simple_results,llm_results
2025-09-23T20:19:51.441706,updateAlbum_response_2,200,1,0,0.0,simple_only,,Injection Attacks,,0,1,0,0,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""SQL Injection (SQLi) Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""SQL injection vulnerability detected - malicious SQL patterns found in response"", ""evidence"": ""Response status: 200, SQL patterns detected in response""}]",[]
2025-09-23T20:20:06.660258,updateAlbum_response_3,200,1,1,1.0,both_detected,Injection Attacks,,,0,1,0,1,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""Cross-Site Scripting (XSS) Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""XSS injection vulnerability detected - malicious script patterns found in response"", ""evidence"": ""Response status: 200, XSS patterns detected in response data""}]","[{""detection_name"": ""LLM: xss_injection"", ""detection"": ""vulnerable"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response returns unescaped HTML/JavaScript in the title field: the value of data.updateAlbum.title is \""<script>alert('xss')</script>\"". This indicates user-controlled input was persisted/reflected by the API without sanitization or encoding. If a client renders this value into a web page DOM without proper output encoding or sanitization, it would allow execution of arbitrary JavaScript (stored/reflected XSS). While the API response alone does not prove client-side rendering is vulnerable, returning raw script tags from the API is a clear unsafe behavior and constitutes a high-risk XSS vector. Recommend validating/encoding/sanitizing input on write, performing context-aware output encoding on render, and implementing CSP to mitigate impact."", ""evidence"": ""\""data.updateAlbum.title\"": \""<script>alert('xss')</script>\"""", ""confidence"": 0.9, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""xss_injection"", ""severity"": ""HIGH"", ""confidence"": 0.9, ""evidence"": ""\""data.updateAlbum.title\"": \""<script>alert('xss')</script>\"""", ""explanation"": ""The GraphQL response returns unescaped HTML/JavaScript in the title field: the value of data.updateAlbum.title is \""<script>alert('xss')</script>\"". This indicates user-controlled input was persisted/reflected by the API without sanitization or encoding. If a client renders this value into a web page DOM without proper output encoding or sanitization, it would allow execution of arbitrary JavaScript (stored/reflected XSS). While the API response alone does not prove client-side rendering is vulnerable, returning raw script tags from the API is a clear unsafe behavior and constitutes a high-risk XSS vector. Recommend validating/encoding/sanitizing input on write, performing context-aware output encoding on render, and implementing CSP to mitigate impact.""}}]"
2025-09-23T20:20:31.142131,updateAlbum_response_4,200,1,0,0.0,simple_only,,Injection Attacks,,0,1,0,0,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""Server-Side Request Forgery (SSRF) Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""SSRF injection vulnerability detected - internal network access patterns found"", ""evidence"": ""Response status: 200, SSRF keywords detected in response""}]",[]
2025-09-23T20:20:46.967022,updateAlbum_response_5,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-23T20:21:03.100187,updateAlbum_response_6,200,1,0,0.0,simple_only,,Injection Attacks,,0,1,0,0,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""Path Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""Path injection vulnerability detected - file system access patterns found"", ""evidence"": ""Response status: 200, Path injection patterns detected in response""}]",[]
2025-09-23T20:21:15.072789,updateAlbum_response_7,200,1,1,1.0,both_detected,Injection Attacks,,,0,1,0,1,0,0,0.0,simple_potential_only,,Injection Attacks,,"[{""detection_name"": ""HTML Injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""HTML injection vulnerability detected - HTML markup found in response"", ""evidence"": ""Response status: 200, HTML patterns detected in response data""}]","[{""detection_name"": ""LLM: html_injection"", ""detection"": ""vulnerable"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response returns a field (title) containing raw HTML markup with an active event handler (an <img> tag with onerror JavaScript). This is clear evidence that HTML/JS was accepted and reflected by the API. If a client renders this value into a page without proper output encoding or sanitization (e.g., using innerHTML), it would execute the onerror handler and result in XSS. Mitigations: validate or strip HTML on input, encode/escape HTML on output, or use a safe rendering method (treat values as plain text). To fully confirm exploitability you must verify how the client renders this field, but the presence of the unescaped payload in the API response demonstrates an HTML injection risk."", ""evidence"": ""\""title\"": \""<img src=\\\""x\\\"" onerror=\\\""alert('html')\\\"" />\"""", ""confidence"": 0.8, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""html_injection"", ""severity"": ""HIGH"", ""confidence"": 0.8, ""evidence"": ""\""title\"": \""<img src=\\\""x\\\"" onerror=\\\""alert('html')\\\"" />\"""", ""explanation"": ""The GraphQL response returns a field (title) containing raw HTML markup with an active event handler (an <img> tag with onerror JavaScript). This is clear evidence that HTML/JS was accepted and reflected by the API. If a client renders this value into a page without proper output encoding or sanitization (e.g., using innerHTML), it would execute the onerror handler and result in XSS. Mitigations: validate or strip HTML on input, encode/escape HTML on output, or use a safe rendering method (treat values as plain text). To fully confirm exploitability you must verify how the client renders this field, but the presence of the unescaped payload in the API response demonstrates an HTML injection risk.""}}]"
2025-09-23T20:21:24.458776,updateAlbum_response_8,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-23T20:21:33.851554,updateAlbum_response_9,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-23T20:21:56.652812,updateAlbum_response_10,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-23T20:22:10.844954,updateAlbum_response_11,400,1,1,0.0,both_detected,,Information Disclosure,Unknown,1,0,0,0,0,1,0.0,no_potential,,,,"[{""detection_name"": ""Field Suggestions Enabled"", ""detection"": ""vulnerable"", ""category"": ""Information Disclosure"", ""description"": ""Field suggestions enabled - potential information disclosure"", ""evidence"": ""Found \""did you mean\"" in error message - field suggestions are enabled""}]","[{""detection_name"": ""LLM: field_suggestions"", ""detection"": ""safe"", ""category"": ""Unknown"", ""description"": ""The GraphQL response returns a helpful suggestion that reveals the correct field name on the Album type: \""Did you mean \\\""title\\\""?\"". This is a field_suggestions information-disclosure issue: an attacker can use such suggestions to enumerate schema details (field names and types) without authentication, making it easier to craft further targeted queries or perform automated schema discovery. The status code and validation error further confirm the server is returning detailed GraphQL validation feedback.\n\nAlthough this does not directly execute code or expose sensitive data, leaking schema details increases reconnaissance capability and should be treated as information disclosure. Mitigation: disable or suppress field-suggestion messages in production (turn off debug/verbose validation messages), return generic validation errors, and implement rate-limiting and authentication to reduce automated schema enumeration risk."", ""evidence"": ""Error message: \""Cannot query field \\\""titel\\\"" on type \\\""Album\\\"". Did you mean \\\""title\\\""?\"" (extensions.code: \""GRAPHQL_VALIDATION_FAILED\"")"", ""confidence"": 0.95, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""field_suggestions"", ""severity"": ""LOW"", ""confidence"": 0.95, ""evidence"": ""Error message: \""Cannot query field \\\""titel\\\"" on type \\\""Album\\\"". Did you mean \\\""title\\\""?\"" (extensions.code: \""GRAPHQL_VALIDATION_FAILED\"")"", ""explanation"": ""The GraphQL response returns a helpful suggestion that reveals the correct field name on the Album type: \""Did you mean \\\""title\\\""?\"". This is a field_suggestions information-disclosure issue: an attacker can use such suggestions to enumerate schema details (field names and types) without authentication, making it easier to craft further targeted queries or perform automated schema discovery. The status code and validation error further confirm the server is returning detailed GraphQL validation feedback.\n\nAlthough this does not directly execute code or expose sensitive data, leaking schema details increases reconnaissance capability and should be treated as information disclosure. Mitigation: disable or suppress field-suggestion messages in production (turn off debug/verbose validation messages), return generic validation errors, and implement rate-limiting and authentication to reduce automated schema enumeration risk.""}}]"
