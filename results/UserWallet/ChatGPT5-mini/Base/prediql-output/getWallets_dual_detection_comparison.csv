timestamp,node_name,response_status,simple_count,llm_count,agreement_score,consensus,common_categories,simple_unique,llm_unique,simple_vulnerable_count,simple_potential_count,simple_safe_count,llm_vulnerable_count,llm_potential_count,llm_safe_count,potential_agreement_score,potential_consensus,common_potential_categories,simple_unique_potential,llm_unique_potential,simple_results,llm_results
2025-10-08T14:49:31.008970,getWallets_response_1,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T14:49:43.072176,getWallets_response_2,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T14:49:52.967950,getWallets_response_3,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T14:50:02.354311,getWallets_response_4,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T14:50:13.097779,getWallets_response_5,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T14:50:23.792086,getWallets_response_6,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T14:50:49.257962,getWallets_response_7,,0,1,0.0,llm_only,,,Access Control,0,0,0,0,1,0,0.0,llm_potential_only,,,Access Control,[],"[{""detection_name"": ""LLM: query_deny_bypass"", ""detection"": ""potential"", ""category"": ""Access Control"", ""description"": ""The non-aliased query response includes GraphQL errors (interpreted here as the query being blocked/partial) yet still returns data entries with sensitive fields populated. The aliased query (using alias 's') returns effectively the same populated data (again with errors). According to the detection rules provided, when a non-aliased query is blocked/returns errors but an aliased form returns data, this indicates an access-control discrepancy that can be exploited via aliases. Both responses include errors, but the aliased response still exposes the same user-related data. Because the aliased query returns data despite the non-aliased query producing errors, this is a POTENTIAL query deny bypass. I rate confidence moderate (0.6) because both responses contain errors (not a clean success vs clean failure), but the presence of equivalent data under the alias strongly suggests an ACL handling difference that could be abused. Recommend manual verification by reproducing the exact queries (aliased vs non-aliased) and reviewing resolver/access-control logic to confirm and remediate."", ""evidence"": ""Non-aliased response (status 200) contains GraphQL errors: \""Cannot return null for non-nullable field Wallet.user.\"" while still returning data.getWallets entries (e.g. wallet-4, wallet-6, wallet-7 with populated user fields). The aliased response (status 200) shows the same behavior under alias \""s\"": errors present but data.s contains the same wallet entries with populated user fields (e.g. wallet-4, wallet-6, etc.)."", ""confidence"": 0.6, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""query_deny_bypass"", ""severity"": ""MEDIUM"", ""confidence"": 0.6, ""evidence"": ""Non-aliased response (status 200) contains GraphQL errors: \""Cannot return null for non-nullable field Wallet.user.\"" while still returning data.getWallets entries (e.g. wallet-4, wallet-6, wallet-7 with populated user fields). The aliased response (status 200) shows the same behavior under alias \""s\"": errors present but data.s contains the same wallet entries with populated user fields (e.g. wallet-4, wallet-6, etc.)."", ""explanation"": ""The non-aliased query response includes GraphQL errors (interpreted here as the query being blocked/partial) yet still returns data entries with sensitive fields populated. The aliased query (using alias 's') returns effectively the same populated data (again with errors). According to the detection rules provided, when a non-aliased query is blocked/returns errors but an aliased form returns data, this indicates an access-control discrepancy that can be exploited via aliases. Both responses include errors, but the aliased response still exposes the same user-related data. Because the aliased query returns data despite the non-aliased query producing errors, this is a POTENTIAL query deny bypass. I rate confidence moderate (0.6) because both responses contain errors (not a clean success vs clean failure), but the presence of equivalent data under the alias strongly suggests an ACL handling difference that could be abused. Recommend manual verification by reproducing the exact queries (aliased vs non-aliased) and reviewing resolver/access-control logic to confirm and remediate.""}}]"
2025-10-08T14:51:18.117768,getWallets_response_8,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T14:51:31.520187,getWallets_response_9,200,1,1,0.0,both_detected,,Information Disclosure,Injection Attacks,1,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,"[{""detection_name"": ""Introspection Enabled"", ""detection"": ""vulnerable"", ""category"": ""Information Disclosure"", ""description"": ""GraphQL introspection enabled - potential information disclosure"", ""evidence"": ""Found __schema in response data - introspection queries are allowed""}]","[{""detection_name"": ""LLM: Introspection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response includes the __schema introspection payload listing types, queries and mutations (Query, Mutation, Wallet, User, etc.). This is a clear indication that GraphQL introspection is enabled and accessible. Exposed schema information allows attackers to enumerate available queries/mutations and field names (including create/delete/update operations) and to craft more targeted attacks (reconnaissance for injection, authorization bypass, SSRF or other abuse). While introspection alone is informational, in an internet-facing production API it increases attack surface and can facilitate higher-risk exploits; therefore it is recommended to disable or restrict introspection in production (or require strong authentication/authorization) to reduce risk."", ""evidence"": ""Response body contains a top-level \""__schema\"" object with \""types\"" including Query and Mutation (e.g. \""__schema\"": { \""types\"": [ { \""name\"": \""Query\"", \""fields\"": [...] }, { \""name\"": \""Mutation\"", \""fields\"": [...] }, { \""name\"": \""Wallet\"", \""fields\"": [...] }, ... ] } )."", ""confidence"": 1.0, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""Introspection"", ""severity"": ""MEDIUM"", ""confidence"": 1.0, ""evidence"": ""Response body contains a top-level \""__schema\"" object with \""types\"" including Query and Mutation (e.g. \""__schema\"": { \""types\"": [ { \""name\"": \""Query\"", \""fields\"": [...] }, { \""name\"": \""Mutation\"", \""fields\"": [...] }, { \""name\"": \""Wallet\"", \""fields\"": [...] }, ... ] } )."", ""explanation"": ""The GraphQL response includes the __schema introspection payload listing types, queries and mutations (Query, Mutation, Wallet, User, etc.). This is a clear indication that GraphQL introspection is enabled and accessible. Exposed schema information allows attackers to enumerate available queries/mutations and field names (including create/delete/update operations) and to craft more targeted attacks (reconnaissance for injection, authorization bypass, SSRF or other abuse). While introspection alone is informational, in an internet-facing production API it increases attack surface and can facilitate higher-risk exploits; therefore it is recommended to disable or restrict introspection in production (or require strong authentication/authorization) to reduce risk.""}}]"
2025-10-08T14:52:02.369176,getWallets_response_10,400,1,1,0.0,both_detected,,Information Disclosure,Unknown,1,0,0,0,1,0,0.0,llm_potential_only,,,Unknown,"[{""detection_name"": ""Field Suggestions Enabled"", ""detection"": ""vulnerable"", ""category"": ""Information Disclosure"", ""description"": ""Field suggestions enabled - potential information disclosure"", ""evidence"": ""Found \""did you mean\"" in error message - field suggestions are enabled""}]","[{""detection_name"": ""LLM: field_suggestions"", ""detection"": ""potential"", ""category"": ""Unknown"", ""description"": ""The GraphQL response includes explicit 'Did you mean ...?' suggestions for invalid field names (e.g. recommending \""name\"", \""balance\"", \""abbreviation\"", \""symbol\"", \""firstName\""). This leaks schema details (field names and related types) and even includes server-side stack traces in the error extensions. Such suggestions facilitate schema enumeration and reconnaissance by attackers, making it easier to craft valid queries and discover data shapes. Recommended mitigations: disable field suggestion output and any detailed error messages in production, remove or redact stacktraces (use a sanitized formatError), disable or protect introspection in untrusted contexts, and return generic validation error messages that do not reveal schema identifiers."", ""evidence"": ""Error messages: \""Cannot query field \\\""nam\\\"" on type \\\""Wallet\\\"". Did you mean \\\""name\\\""?\""; \""Cannot query field \\\""balancee\\\"" on type \\\""Wallet\\\"". Did you mean \\\""balance\\\""?\""; \""Cannot query field \\\""abbreviaton\\\"" on type \\\""Currency\\\"". Did you mean \\\""abbreviation\\\""?\""; \""Cannot query field \\\""symb\\\"" on type \\\""Currency\\\"". Did you mean \\\""symbol\\\""?\""; \""Cannot query field \\\""firstNam\\\"" on type \\\""User\\\"". Did you mean \\\""firstName\\\"" or \\\""lastName\\\""?\"""", ""confidence"": 0.9, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""field_suggestions"", ""severity"": ""MEDIUM"", ""confidence"": 0.9, ""evidence"": ""Error messages: \""Cannot query field \\\""nam\\\"" on type \\\""Wallet\\\"". Did you mean \\\""name\\\""?\""; \""Cannot query field \\\""balancee\\\"" on type \\\""Wallet\\\"". Did you mean \\\""balance\\\""?\""; \""Cannot query field \\\""abbreviaton\\\"" on type \\\""Currency\\\"". Did you mean \\\""abbreviation\\\""?\""; \""Cannot query field \\\""symb\\\"" on type \\\""Currency\\\"". Did you mean \\\""symbol\\\""?\""; \""Cannot query field \\\""firstNam\\\"" on type \\\""User\\\"". Did you mean \\\""firstName\\\"" or \\\""lastName\\\""?\"""", ""explanation"": ""The GraphQL response includes explicit 'Did you mean ...?' suggestions for invalid field names (e.g. recommending \""name\"", \""balance\"", \""abbreviation\"", \""symbol\"", \""firstName\""). This leaks schema details (field names and related types) and even includes server-side stack traces in the error extensions. Such suggestions facilitate schema enumeration and reconnaissance by attackers, making it easier to craft valid queries and discover data shapes. Recommended mitigations: disable field suggestion output and any detailed error messages in production, remove or redact stacktraces (use a sanitized formatError), disable or protect introspection in untrusted contexts, and return generic validation error messages that do not reveal schema identifiers.""}}]"
