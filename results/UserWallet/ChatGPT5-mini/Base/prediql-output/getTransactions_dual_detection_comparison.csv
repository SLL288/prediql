timestamp,node_name,response_status,simple_count,llm_count,agreement_score,consensus,common_categories,simple_unique,llm_unique,simple_vulnerable_count,simple_potential_count,simple_safe_count,llm_vulnerable_count,llm_potential_count,llm_safe_count,potential_agreement_score,potential_consensus,common_potential_categories,simple_unique_potential,llm_unique_potential,simple_results,llm_results
2025-10-09T18:45:43.901703,getTransactions_response_2,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-09T18:45:57.254135,getTransactions_response_3,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-09T18:46:11.365228,getTransactions_response_4,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-09T18:46:25.181940,getTransactions_response_5,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-09T18:46:39.154199,getTransactions_response_6,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-09T18:46:51.605663,getTransactions_response_7,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-09T18:47:44.763678,getTransactions_response_8,,0,1,0.0,llm_only,,,Access Control,0,0,0,1,0,0,0.0,no_potential,,,,[],"[{""detection_name"": ""LLM: query_deny_bypass"", ""detection"": ""vulnerable"", ""category"": ""Access Control"", ""description"": ""Both queries returned HTTP 200, but the non-aliased query response contains many GraphQL errors indicating access to certain non-nullable fields failed (e.g. Transaction.payer, Transaction.wallet). The aliased query used query aliases (root alias 's' and renamed fields like acct/actor) and returned data rows for the same underlying objects despite similar GraphQL errors. According to the detection criteria, a deny/bypass is suspected when a non-aliased request is blocked/errored while an aliased request is able to return data for the same operation. Here the aliased response returns the same records and sensitive/test strings (introspection marker and updated name) that were associated with denied fields in the non-aliased response. Although both responses include execution errors, the aliased query still yields substantive data for fields that the non-aliased query could not fully resolve, which matches the pattern of an access-control bypass via aliases. This is a potential query deny bypass vulnerability: an attacker may be able to circumvent intended deny rules/field protections by using aliases or different selection structure. Recommended remediation: ensure authorization is enforced at the resolver/data-access layer (not by field name or query shape), normalize/validate query field names/aliases before execution, and reject/deny queries that attempt to access forbidden fields regardless of aliasing."", ""evidence"": ""Non-aliased response (status 200) contains GraphQL errors: \""Cannot return null for non-nullable field Transaction.payer.\"" and \""Cannot return null for non-nullable field Transaction.wallet.\"" while also returning data.getTransactions entries (e.g. transaction-4 with payer and wallet fields). The aliased response (status 200) also contains errors but returns data.s with the same items (transaction-4, transaction-7, transaction-9, transaction-10) where formerly-blocked fields are present under aliased names (acct/actor vs wallet/payer). The aliased data includes suspicious/intentional test values such as \""__INTROSPECT_TEST__\"", \""__schema{types{name}}\"" and \""Updated via Deny Bypass Aliased\"" indicating access to fields that produced errors in the non-aliased query."", ""confidence"": 0.8, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""query_deny_bypass"", ""severity"": ""HIGH"", ""confidence"": 0.8, ""evidence"": ""Non-aliased response (status 200) contains GraphQL errors: \""Cannot return null for non-nullable field Transaction.payer.\"" and \""Cannot return null for non-nullable field Transaction.wallet.\"" while also returning data.getTransactions entries (e.g. transaction-4 with payer and wallet fields). The aliased response (status 200) also contains errors but returns data.s with the same items (transaction-4, transaction-7, transaction-9, transaction-10) where formerly-blocked fields are present under aliased names (acct/actor vs wallet/payer). The aliased data includes suspicious/intentional test values such as \""__INTROSPECT_TEST__\"", \""__schema{types{name}}\"" and \""Updated via Deny Bypass Aliased\"" indicating access to fields that produced errors in the non-aliased query."", ""explanation"": ""Both queries returned HTTP 200, but the non-aliased query response contains many GraphQL errors indicating access to certain non-nullable fields failed (e.g. Transaction.payer, Transaction.wallet). The aliased query used query aliases (root alias 's' and renamed fields like acct/actor) and returned data rows for the same underlying objects despite similar GraphQL errors. According to the detection criteria, a deny/bypass is suspected when a non-aliased request is blocked/errored while an aliased request is able to return data for the same operation. Here the aliased response returns the same records and sensitive/test strings (introspection marker and updated name) that were associated with denied fields in the non-aliased response. Although both responses include execution errors, the aliased query still yields substantive data for fields that the non-aliased query could not fully resolve, which matches the pattern of an access-control bypass via aliases. This is a potential query deny bypass vulnerability: an attacker may be able to circumvent intended deny rules/field protections by using aliases or different selection structure. Recommended remediation: ensure authorization is enforced at the resolver/data-access layer (not by field name or query shape), normalize/validate query field names/aliases before execution, and reject/deny queries that attempt to access forbidden fields regardless of aliasing.""}}]"
2025-10-09T18:48:25.480320,getTransactions_response_9,,0,1,0.0,llm_only,,,Access Control,0,0,0,1,0,0,0.0,no_potential,,,,[],"[{""detection_name"": ""LLM: query_deny_bypass"", ""detection"": ""vulnerable"", ""category"": ""Access Control"", ""description"": ""Comparison of the two GraphQL responses shows behavior consistent with a query-deny bypass via aliases. The non-aliased query returned many GraphQL execution errors specifically complaining that non-nullable fields Transaction.payer and Transaction.wallet could not be returned (i.e. access or resolution was blocked/erroring for those fields). The aliased query used aliases (root alias 's' and field aliases like 'actor' and 'acct') and, although it also reports many internal errors, it still returns populated data for the same logical objects and nested user/wallet fields (including sensitive-looking values and introspection-test strings). This indicates that the server's access-control or error-handling logic treats the aliased fields differently (or validates names differently), allowing data to be returned when the same fields were blocked or produced null errors without aliases. Per the detection criteria: the non-aliased query contained blocking errors, and the aliased query returned the target data (albeit with errors). Because the aliased request is able to surface the same fields/data that the non-aliased request could not, this is a likely query deny bypass vulnerability. Severity is rated HIGH because leaking user/wallet data or enabling introspection via aliasing can expose sensitive information and enable further attacks. Confidence is high but not maximal because both responses do contain errors (the aliased response is not entirely clean), so this is classified as a strong positive (potential/likely bypass) rather than an absolute, noiseless confirmation."", ""evidence"": ""Non-aliased response contains repeated errors: \""Cannot return null for non-nullable field Transaction.payer.\"" and \""Cannot return null for non-nullable field Transaction.wallet.\"" (paths like [\""getTransactions\"", <index>, \""payer\""] / [\""getTransactions\"", <index>, \""wallet\""]). The aliased response (alias root 's' and field aliases 'actor'/'acct') returns the same transactional objects and nested user/wallet data despite also containing errors. Example: aliased data includes { \""actor\"": { \""id\"": \""user-2\"", \""firstName\"": \""__INTROSPECT_TEST__\"", \""description\"": \""__schema{types{name}}\"" }, \""acct\"": { \""id\"": \""wallet-4\"", \""name\"": \""Updated via Deny Bypass Aliased\"", \""user\"": { \""firstName\"": \""__INTROSPECT_TEST__\"" } } }, while the non-aliased response shows errors preventing payer/wallet fields."", ""confidence"": 0.8, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""query_deny_bypass"", ""severity"": ""HIGH"", ""confidence"": 0.8, ""evidence"": ""Non-aliased response contains repeated errors: \""Cannot return null for non-nullable field Transaction.payer.\"" and \""Cannot return null for non-nullable field Transaction.wallet.\"" (paths like [\""getTransactions\"", <index>, \""payer\""] / [\""getTransactions\"", <index>, \""wallet\""]). The aliased response (alias root 's' and field aliases 'actor'/'acct') returns the same transactional objects and nested user/wallet data despite also containing errors. Example: aliased data includes { \""actor\"": { \""id\"": \""user-2\"", \""firstName\"": \""__INTROSPECT_TEST__\"", \""description\"": \""__schema{types{name}}\"" }, \""acct\"": { \""id\"": \""wallet-4\"", \""name\"": \""Updated via Deny Bypass Aliased\"", \""user\"": { \""firstName\"": \""__INTROSPECT_TEST__\"" } } }, while the non-aliased response shows errors preventing payer/wallet fields."", ""explanation"": ""Comparison of the two GraphQL responses shows behavior consistent with a query-deny bypass via aliases. The non-aliased query returned many GraphQL execution errors specifically complaining that non-nullable fields Transaction.payer and Transaction.wallet could not be returned (i.e. access or resolution was blocked/erroring for those fields). The aliased query used aliases (root alias 's' and field aliases like 'actor' and 'acct') and, although it also reports many internal errors, it still returns populated data for the same logical objects and nested user/wallet fields (including sensitive-looking values and introspection-test strings). This indicates that the server's access-control or error-handling logic treats the aliased fields differently (or validates names differently), allowing data to be returned when the same fields were blocked or produced null errors without aliases. Per the detection criteria: the non-aliased query contained blocking errors, and the aliased query returned the target data (albeit with errors). Because the aliased request is able to surface the same fields/data that the non-aliased request could not, this is a likely query deny bypass vulnerability. Severity is rated HIGH because leaking user/wallet data or enabling introspection via aliasing can expose sensitive information and enable further attacks. Confidence is high but not maximal because both responses do contain errors (the aliased response is not entirely clean), so this is classified as a strong positive (potential/likely bypass) rather than an absolute, noiseless confirmation.""}}]"
2025-10-09T18:48:45.655676,getTransactions_response_10,200,1,1,0.0,both_detected,,Information Disclosure,Injection Attacks,1,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,"[{""detection_name"": ""Introspection Enabled"", ""detection"": ""vulnerable"", ""category"": ""Information Disclosure"", ""description"": ""GraphQL introspection enabled - potential information disclosure"", ""evidence"": ""Found __schema in response data - introspection queries are allowed""}]","[{""detection_name"": ""LLM: introspection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response contains a __schema object with a types list and queryType, and it enumerates application types and fields (e.g. Query and Mutation fields such as getUser, createTransaction, deleteWallet, updateUser, etc.). This is clear evidence that GraphQL introspection is enabled and the server is exposing its schema. Exposed schema information significantly aids attackers in reconnaissance by revealing available queries/mutations, object structures, and field names which can be used to craft more focused attacks (e.g. attempting sensitive mutations, parameter fuzzing, or discovering privileged operations). In production environments this should be disabled or restricted to authorized users."", ""evidence"": ""\""__schema\"": { \""types\"": [ ... ], \""queryType\"": { \""name\"": \""Query\"" } }"", ""confidence"": 0.95, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""introspection"", ""severity"": ""MEDIUM"", ""confidence"": 0.95, ""evidence"": ""\""__schema\"": { \""types\"": [ ... ], \""queryType\"": { \""name\"": \""Query\"" } }"", ""explanation"": ""The GraphQL response contains a __schema object with a types list and queryType, and it enumerates application types and fields (e.g. Query and Mutation fields such as getUser, createTransaction, deleteWallet, updateUser, etc.). This is clear evidence that GraphQL introspection is enabled and the server is exposing its schema. Exposed schema information significantly aids attackers in reconnaissance by revealing available queries/mutations, object structures, and field names which can be used to craft more focused attacks (e.g. attempting sensitive mutations, parameter fuzzing, or discovering privileged operations). In production environments this should be disabled or restricted to authorized users.""}}]"
2025-10-09T18:49:06.308737,getTransactions_response_11,400,1,1,0.0,both_detected,,Information Disclosure,Unknown,1,0,0,0,1,0,0.0,llm_potential_only,,,Unknown,"[{""detection_name"": ""Field Suggestions Enabled"", ""detection"": ""vulnerable"", ""category"": ""Information Disclosure"", ""description"": ""Field suggestions enabled - potential information disclosure"", ""evidence"": ""Found \""did you mean\"" in error message - field suggestions are enabled""}]","[{""detection_name"": ""LLM: field_suggestions"", ""detection"": ""potential"", ""category"": ""Unknown"", ""description"": ""The GraphQL API returns helpful typo suggestions in validation errors (\""Did you mean ...?\"") that reveal exact field names on types (amount, firstName, lastName, currency, etc.). This is a form of information disclosure (field_suggestions) because it allows an attacker to enumerate schema field names without legitimate access, which can facilitate targeted probing or more advanced attacks. The presence of stacktraces in the error extensions further increases information leakage. Recommended mitigation: disable or sanitize suggestion/details in production error messages (turn off debug/stacktrace exposure and avoid returning 'did you mean' hints), or implement a custom error formatter that returns minimal, non-revealing validation errors."", ""evidence"": ""Error messages in response: \""Cannot query field \\\""amont\\\"" on type \\\""Transaction\\\"". Did you mean \\\""amount\\\""?\"", \""Cannot query field \\\""fristName\\\"" on type \\\""User\\\"". Did you mean \\\""firstName\\\"" or \\\""lastName\\\""?\"", \""Cannot query field \\\""curency\\\"" on type \\\""Wallet\\\"". Did you mean \\\""currency\\\""?\"" (stacktraces also present in extensions.exception.stacktrace)."", ""confidence"": 0.95, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""field_suggestions"", ""severity"": ""MEDIUM"", ""confidence"": 0.95, ""evidence"": ""Error messages in response: \""Cannot query field \\\""amont\\\"" on type \\\""Transaction\\\"". Did you mean \\\""amount\\\""?\"", \""Cannot query field \\\""fristName\\\"" on type \\\""User\\\"". Did you mean \\\""firstName\\\"" or \\\""lastName\\\""?\"", \""Cannot query field \\\""curency\\\"" on type \\\""Wallet\\\"". Did you mean \\\""currency\\\""?\"" (stacktraces also present in extensions.exception.stacktrace)."", ""explanation"": ""The GraphQL API returns helpful typo suggestions in validation errors (\""Did you mean ...?\"") that reveal exact field names on types (amount, firstName, lastName, currency, etc.). This is a form of information disclosure (field_suggestions) because it allows an attacker to enumerate schema field names without legitimate access, which can facilitate targeted probing or more advanced attacks. The presence of stacktraces in the error extensions further increases information leakage. Recommended mitigation: disable or sanitize suggestion/details in production error messages (turn off debug/stacktrace exposure and avoid returning 'did you mean' hints), or implement a custom error formatter that returns minimal, non-revealing validation errors.""}}]"
