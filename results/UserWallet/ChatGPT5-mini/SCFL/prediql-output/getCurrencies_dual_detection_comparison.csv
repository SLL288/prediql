timestamp,node_name,response_status,simple_count,llm_count,agreement_score,consensus,common_categories,simple_unique,llm_unique,simple_vulnerable_count,simple_potential_count,simple_safe_count,llm_vulnerable_count,llm_potential_count,llm_safe_count,potential_agreement_score,potential_consensus,common_potential_categories,simple_unique_potential,llm_unique_potential,simple_results,llm_results
2025-10-08T12:45:07.901474,getCurrencies_response_2,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T12:45:20.657783,getCurrencies_response_3,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T12:45:29.479847,getCurrencies_response_4,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T12:45:42.071879,getCurrencies_response_5,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T12:45:56.159102,getCurrencies_response_6,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T12:46:04.545023,getCurrencies_response_7,400,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-10-08T12:46:28.882386,getCurrencies_response_8,,1,1,1.0,both_detected,Access Control,,,0,1,0,1,0,0,0.0,simple_potential_only,,Access Control,,"[{""detection_name"": ""Query Deny Bypass"", ""detection"": ""potential"", ""category"": ""Access Control"", ""description"": ""Query deny bypass vulnerability detected - non-aliased query blocked but aliased query succeeded with errors"", ""evidence"": ""Non-aliased: 400, Aliased: 200, Aliased has errors: True""}]","[{""detection_name"": ""LLM: query_deny_bypass"", ""detection"": ""vulnerable"", ""category"": ""Access Control"", ""description"": ""The non-aliased query was blocked (HTTP 400) and returned a GraphQL validation error about an unknown argument on Query.getCurrencies. The aliased query (returned under alias 's') returned HTTP 200 and includes a populated data.s array with many Currency records (including entries named 'AliasedBypass'/'BYPASS' and potentially sensitive/injected values), even though the aliased response also contains field-level errors. According to the detection criteria, when the non-aliased request is blocked but an aliased version returns data, this indicates a query deny bypass where access or filtering can be bypassed using aliases. Caveat: the 400 on the non-aliased request is a schema validation error (unknown argument) rather than an explicit access-denied message, so it is possible the original non-aliased request was malformed. Nevertheless, the aliased request succeeded in returning data despite errors, which is sufficient for a potential/likely query-deny bypass. Recommended next steps: reproduce the exact queries (non-aliased vs aliased) to confirm identical intent, verify whether aliasing changes validation/authorization paths, and fix server-side validation/authorization to treat aliased and non-aliased fields equivalently and not leak data when validation fails."", ""evidence"": ""Non-aliased response: HTTP 400 with error \""Unknown argument \\\""input\\\"" on field \\\""Query.getCurrencies\\\"".\""; Aliased response: HTTP 200 with data present under field \""data.s\"" (many Currency entries including items labelled 'AliasedBypass' and 'BYPASS'), plus errors such as \""Cannot return null for non-nullable field Currency.country.\"""", ""confidence"": 0.75, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""query_deny_bypass"", ""severity"": ""HIGH"", ""confidence"": 0.75, ""evidence"": ""Non-aliased response: HTTP 400 with error \""Unknown argument \\\""input\\\"" on field \\\""Query.getCurrencies\\\"".\""; Aliased response: HTTP 200 with data present under field \""data.s\"" (many Currency entries including items labelled 'AliasedBypass' and 'BYPASS'), plus errors such as \""Cannot return null for non-nullable field Currency.country.\"""", ""explanation"": ""The non-aliased query was blocked (HTTP 400) and returned a GraphQL validation error about an unknown argument on Query.getCurrencies. The aliased query (returned under alias 's') returned HTTP 200 and includes a populated data.s array with many Currency records (including entries named 'AliasedBypass'/'BYPASS' and potentially sensitive/injected values), even though the aliased response also contains field-level errors. According to the detection criteria, when the non-aliased request is blocked but an aliased version returns data, this indicates a query deny bypass where access or filtering can be bypassed using aliases. Caveat: the 400 on the non-aliased request is a schema validation error (unknown argument) rather than an explicit access-denied message, so it is possible the original non-aliased request was malformed. Nevertheless, the aliased request succeeded in returning data despite errors, which is sufficient for a potential/likely query-deny bypass. Recommended next steps: reproduce the exact queries (non-aliased vs aliased) to confirm identical intent, verify whether aliasing changes validation/authorization paths, and fix server-side validation/authorization to treat aliased and non-aliased fields equivalently and not leak data when validation fails.""}}]"
2025-10-08T12:46:48.372786,getCurrencies_response_9,200,0,1,0.0,llm_only,,,Injection Attacks,0,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,[],"[{""detection_name"": ""LLM: Introspection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response includes an __type object that enumerates the 'Currency' type and its fields (id, abbreviation, symbol, rate, country). This is clear evidence that GraphQL introspection is enabled and returning schema metadata. Exposed schema information makes it easier for an attacker to discover available types and fields, craft targeted queries, and find potentially sensitive data or exploitable operations. Recommended mitigations: disable or restrict introspection in production (or restrict to authenticated/authorized users), implement query depth/complexity limits and proper access controls on resolvers, and monitor for abnormal querying activity."", ""evidence"": ""\""__type\"": { \""name\"": \""Currency\"", \""fields\"": [ { \""name\"": \""id\"", ... }, { \""name\"": \""abbreviation\"", ... }, { \""name\"": \""symbol\"", ... }, { \""name\"": \""rate\"", ... }, { \""name\"": \""country\"", ... } ] }"", ""confidence"": 0.95, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""Introspection"", ""severity"": ""MEDIUM"", ""confidence"": 0.95, ""evidence"": ""\""__type\"": { \""name\"": \""Currency\"", \""fields\"": [ { \""name\"": \""id\"", ... }, { \""name\"": \""abbreviation\"", ... }, { \""name\"": \""symbol\"", ... }, { \""name\"": \""rate\"", ... }, { \""name\"": \""country\"", ... } ] }"", ""explanation"": ""The GraphQL response includes an __type object that enumerates the 'Currency' type and its fields (id, abbreviation, symbol, rate, country). This is clear evidence that GraphQL introspection is enabled and returning schema metadata. Exposed schema information makes it easier for an attacker to discover available types and fields, craft targeted queries, and find potentially sensitive data or exploitable operations. Recommended mitigations: disable or restrict introspection in production (or restrict to authenticated/authorized users), implement query depth/complexity limits and proper access controls on resolvers, and monitor for abnormal querying activity.""}}]"
2025-10-08T12:46:59.879205,getCurrencies_response_10,400,1,1,0.0,both_detected,,Information Disclosure,Unknown,1,0,0,0,1,0,0.0,llm_potential_only,,,Unknown,"[{""detection_name"": ""Field Suggestions Enabled"", ""detection"": ""vulnerable"", ""category"": ""Information Disclosure"", ""description"": ""Field suggestions enabled - potential information disclosure"", ""evidence"": ""Found \""did you mean\"" in error message - field suggestions are enabled""}]","[{""detection_name"": ""LLM: field_suggestions"", ""detection"": ""potential"", ""category"": ""Unknown"", ""description"": ""The GraphQL response includes an explicit field suggestion that reveals schema details: when the client queried an unknown field 'abbrevation' the server responded with a corrected field name 'abbreviation'. This behavior leaks internal schema information (available types/fields and likely field names), which aids an attacker in enumerating and mapping the GraphQL schema for further targeted probing or exploitation. Such leakage is a form of information disclosure; it is not an immediate code-execution vulnerability but materially reduces the effort required for reconnaissance. Mitigations include disabling or suppressing suggestion messages in error output, returning generic validation errors, and enforcing strict error handling that does not reveal schema internals."", ""evidence"": ""Error message: \""Cannot query field \\\""abbrevation\\\"" on type \\\""Currency\\\"". Did you mean \\\""abbreviation\\\""?\"""", ""confidence"": 0.95, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""field_suggestions"", ""severity"": ""MEDIUM"", ""confidence"": 0.95, ""evidence"": ""Error message: \""Cannot query field \\\""abbrevation\\\"" on type \\\""Currency\\\"". Did you mean \\\""abbreviation\\\""?\"""", ""explanation"": ""The GraphQL response includes an explicit field suggestion that reveals schema details: when the client queried an unknown field 'abbrevation' the server responded with a corrected field name 'abbreviation'. This behavior leaks internal schema information (available types/fields and likely field names), which aids an attacker in enumerating and mapping the GraphQL schema for further targeted probing or exploitation. Such leakage is a form of information disclosure; it is not an immediate code-execution vulnerability but materially reduces the effort required for reconnaissance. Mitigations include disabling or suppressing suggestion messages in error output, returning generic validation errors, and enforcing strict error handling that does not reveal schema internals.""}}]"
