timestamp,node_name,response_status,simple_count,llm_count,agreement_score,consensus,common_categories,simple_unique,llm_unique,simple_vulnerable_count,simple_potential_count,simple_safe_count,llm_vulnerable_count,llm_potential_count,llm_safe_count,potential_agreement_score,potential_consensus,common_potential_categories,simple_unique_potential,llm_unique_potential,simple_results,llm_results
2025-09-22T19:35:45.119821,countries_response_2,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:36:08.389484,countries_response_3,200,0,1,0.0,llm_only,,,Injection Attacks,0,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,[],"[{""detection_name"": ""LLM: xss_injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response echoes the exact payload \""<script>alert('xss')</script>\"" back inside an error message. This is reflected output of attacker-controlled input. While the server is returning a validation error (not executing the script), the raw script tag is present in the response. If a client (web app) renders this error message into the DOM without proper escaping/encoding, it would result in reflected XSS. The vulnerability is not confirmed as an immediate browser exploit from this response alone, but the presence of unsanitized reflected input is a clear XSS risk and should be remediated (encode/escape user input in error messages or avoid reflecting raw input)."", ""evidence"": ""GraphQL error message contains the raw input: \""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""<script>alert('xss')</script>\\\"".\"""", ""confidence"": 0.8, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""xss_injection"", ""severity"": ""MEDIUM"", ""confidence"": 0.8, ""evidence"": ""GraphQL error message contains the raw input: \""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""<script>alert('xss')</script>\\\"".\"""", ""explanation"": ""The GraphQL response echoes the exact payload \""<script>alert('xss')</script>\"" back inside an error message. This is reflected output of attacker-controlled input. While the server is returning a validation error (not executing the script), the raw script tag is present in the response. If a client (web app) renders this error message into the DOM without proper escaping/encoding, it would result in reflected XSS. The vulnerability is not confirmed as an immediate browser exploit from this response alone, but the presence of unsanitized reflected input is a clear XSS risk and should be remediated (encode/escape user input in error messages or avoid reflecting raw input).""}}]"
2025-09-22T19:36:26.952489,countries_response_4,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:36:50.152396,countries_response_5,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:37:09.874388,countries_response_6,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:37:31.956353,countries_response_7,200,0,1,0.0,llm_only,,,Injection Attacks,0,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,[],"[{""detection_name"": ""LLM: html_injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL error message directly reflects the supplied payload containing an HTML tag with an onerror JavaScript handler: <img src=x onerror=\""alert(1)\"" />. Although the response is JSON-encoded (quotes are escaped), the server echoes raw HTML markup back to the client. If a client (for example a web UI, dashboard, or any frontend) takes this error text and inserts it into a page without proper HTML-escaping or sanitization, it can lead to HTML injection / reflected XSS. This is a reflected injection vector: the server treats user input as data but returns it verbatim in an error context. Recommendation: do not include raw user input in responses, or ensure all returned values are properly escaped/encoded for the intended output context (HTML-escape before inserting into DOM, or return sanitized/plain text). Also consider filtering or validating inputs and using a safe error reporting format that does not reflect untrusted content."", ""evidence"": ""\""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""<img src=x onerror=\\\\\\\""alert(1)\\\\\\\"" />\\\"".\"" (error.message reflecting user-supplied HTML payload)"", ""confidence"": 0.7, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""html_injection"", ""severity"": ""MEDIUM"", ""confidence"": 0.7, ""evidence"": ""\""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""<img src=x onerror=\\\\\\\""alert(1)\\\\\\\"" />\\\"".\"" (error.message reflecting user-supplied HTML payload)"", ""explanation"": ""The GraphQL error message directly reflects the supplied payload containing an HTML tag with an onerror JavaScript handler: <img src=x onerror=\""alert(1)\"" />. Although the response is JSON-encoded (quotes are escaped), the server echoes raw HTML markup back to the client. If a client (for example a web UI, dashboard, or any frontend) takes this error text and inserts it into a page without proper HTML-escaping or sanitization, it can lead to HTML injection / reflected XSS. This is a reflected injection vector: the server treats user input as data but returns it verbatim in an error context. Recommendation: do not include raw user input in responses, or ensure all returned values are properly escaped/encoded for the intended output context (HTML-escape before inserting into DOM, or return sanitized/plain text). Also consider filtering or validating inputs and using a safe error reporting format that does not reflect untrusted content.""}}]"
2025-09-22T19:37:48.163066,countries_response_8,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:38:04.957804,countries_response_9,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:38:22.575220,countries_response_10,200,0,1,0.0,llm_only,,,Injection Attacks,0,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,[],"[{""detection_name"": ""LLM: introspection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL error response reveals internal schema type information (StringQueryOperatorInput). Although this is not an explicit __schema introspection response, leaking type names and expected input types in error messages constitutes schema information disclosure (a form of introspection/leakage). An attacker can use such details to map the API, craft targeted queries, and accelerate further discovery. Recommend suppressing detailed GraphQL validation errors in production, avoiding returning raw type names to clients, implementing generic error messages, and restricting or disabling GraphQL introspection in public environments where appropriate."", ""evidence"": ""Error message: \""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""US\\\"".\"""", ""confidence"": 0.9, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""introspection"", ""severity"": ""MEDIUM"", ""confidence"": 0.9, ""evidence"": ""Error message: \""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""US\\\"".\"""", ""explanation"": ""The GraphQL error response reveals internal schema type information (StringQueryOperatorInput). Although this is not an explicit __schema introspection response, leaking type names and expected input types in error messages constitutes schema information disclosure (a form of introspection/leakage). An attacker can use such details to map the API, craft targeted queries, and accelerate further discovery. Recommend suppressing detailed GraphQL validation errors in production, avoiding returning raw type names to clients, implementing generic error messages, and restricting or disabling GraphQL introspection in public environments where appropriate.""}}]"
2025-09-22T19:40:48.128450,countries_response_1,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:41:05.392435,countries_response_2,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:41:24.968794,countries_response_4,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:41:45.571601,countries_response_5,200,0,1,0.0,llm_only,,,Injection Attacks,0,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,[],"[{""detection_name"": ""LLM: xss_injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL error response directly reflects the user-supplied string \""<script>alert('xss')</script>\"" inside the error message without escaping. This is a classic reflection of raw HTML/JS from input into a response. If a client (web application) inserts these error messages into the DOM as HTML (or otherwise renders them without proper encoding), an attacker could trigger a reflected XSS by supplying a payload like the shown script. The server-side reflection in itself is not proof that an exploit is possible \u2014 exploitation depends on how the client renders error text \u2014 but the presence of unescaped script tags in server responses is a high-risk indicator. Recommend encoding/escaping user input in error messages, stripping/neutralizing HTML in returned messages, or ensuring clients treat error messages as plain text (e.g., textContent) rather than HTML."", ""evidence"": ""errors[1].message: \""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""<script>alert('xss')</script>\\\"".\"""", ""confidence"": 0.8, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""xss_injection"", ""severity"": ""MEDIUM"", ""confidence"": 0.8, ""evidence"": ""errors[1].message: \""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""<script>alert('xss')</script>\\\"".\"""", ""explanation"": ""The GraphQL error response directly reflects the user-supplied string \""<script>alert('xss')</script>\"" inside the error message without escaping. This is a classic reflection of raw HTML/JS from input into a response. If a client (web application) inserts these error messages into the DOM as HTML (or otherwise renders them without proper encoding), an attacker could trigger a reflected XSS by supplying a payload like the shown script. The server-side reflection in itself is not proof that an exploit is possible \u2014 exploitation depends on how the client renders error text \u2014 but the presence of unescaped script tags in server responses is a high-risk indicator. Recommend encoding/escaping user input in error messages, stripping/neutralizing HTML in returned messages, or ensuring clients treat error messages as plain text (e.g., textContent) rather than HTML.""}}]"
2025-09-22T19:42:06.151385,countries_response_6,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:42:29.535878,countries_response_7,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:42:51.470536,countries_response_8,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:43:11.277674,countries_response_9,200,0,1,0.0,llm_only,,,Injection Attacks,0,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,[],"[{""detection_name"": ""LLM: html_injection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The GraphQL response reflects an unescaped HTML payload (<img src=x onerror=\""alert(1)\"" />) in an error message. This indicates the API echoes user-supplied markup back to clients. If a client application inserts these error messages into a web page DOM without proper escaping or sanitization (for example using innerHTML), the reflected markup could execute in users' browsers (reflected XSS / HTML injection). The server-side response itself is JSON and not executing the markup, but the reflected content is a clear injection vector. Recommend encoding/escaping error messages before returning them, validating/sanitizing input, and ensuring clients treat server-sent strings as data (not HTML) when rendering."", ""evidence"": ""GraphQL error message contains unescaped HTML: \""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""<img src=x onerror=\\\\\\\""alert(1)\\\\\\\"" />\\\"".\"""", ""confidence"": 0.8, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""html_injection"", ""severity"": ""MEDIUM"", ""confidence"": 0.8, ""evidence"": ""GraphQL error message contains unescaped HTML: \""Expected value of type \\\""StringQueryOperatorInput\\\"", found \\\""<img src=x onerror=\\\\\\\""alert(1)\\\\\\\"" />\\\"".\"""", ""explanation"": ""The GraphQL response reflects an unescaped HTML payload (<img src=x onerror=\""alert(1)\"" />) in an error message. This indicates the API echoes user-supplied markup back to clients. If a client application inserts these error messages into a web page DOM without proper escaping or sanitization (for example using innerHTML), the reflected markup could execute in users' browsers (reflected XSS / HTML injection). The server-side response itself is JSON and not executing the markup, but the reflected content is a clear injection vector. Recommend encoding/escaping error messages before returning them, validating/sanitizing input, and ensuring clients treat server-sent strings as data (not HTML) when rendering.""}}]"
2025-09-22T19:43:26.531436,countries_response_10,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:43:46.330165,countries_response_11,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:45:51.023023,countries_response_1,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:46:06.282214,countries_response_2,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:46:21.374129,countries_response_3,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:46:39.256290,countries_response_5,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:46:52.972752,countries_response_6,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:47:08.131614,countries_response_7,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:47:25.438977,countries_response_8,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:47:41.510372,countries_response_9,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:48:07.014222,countries_response_10,200,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:48:21.895500,countries_response_11,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:48:33.431035,countries_response_12,,0,0,0.0,no_vulnerabilities,,,,0,0,0,0,0,0,0.0,no_potential,,,,[],[]
2025-09-22T19:48:51.992094,countries_response_13,200,1,1,0.0,both_detected,,Information Disclosure,Injection Attacks,1,0,0,0,1,0,0.0,llm_potential_only,,,Injection Attacks,"[{""detection_name"": ""Introspection Enabled"", ""detection"": ""vulnerable"", ""category"": ""Information Disclosure"", ""description"": ""GraphQL introspection enabled - potential information disclosure"", ""evidence"": ""Found __schema in response data - introspection queries are allowed""}]","[{""detection_name"": ""LLM: GraphQL Introspection"", ""detection"": ""potential"", ""category"": ""Injection Attacks"", ""description"": ""The response contains an active GraphQL introspection result (the __schema object and built-in introspection types such as __Type and __Schema). This indicates that schema introspection is enabled and returning type metadata. Exposed schema information allows attackers to enumerate types, queries, fields, and input shapes, increasing the attack surface and making it easier to craft targeted queries or exploit other vulnerabilities (e.g., data-exposing fields). Mitigation options include disabling introspection in production, enforcing authentication/authorization for introspection queries, applying query whitelisting, and implementing rate limiting and complexity/depth limits to reduce abuse."", ""evidence"": ""\""data\"": { \""__schema\"": { \""types\"": [ { \""name\"": \""Query\"" }, { \""name\"": \""Country\"" }, { \""name\"": \""__Type\"" }, { \""name\"": \""__Schema\"" } ] } }"", ""confidence"": 0.95, ""llm_analysis"": {""is_vulnerable"": true, ""vulnerability_type"": ""GraphQL Introspection"", ""severity"": ""MEDIUM"", ""confidence"": 0.95, ""evidence"": ""\""data\"": { \""__schema\"": { \""types\"": [ { \""name\"": \""Query\"" }, { \""name\"": \""Country\"" }, { \""name\"": \""__Type\"" }, { \""name\"": \""__Schema\"" } ] } }"", ""explanation"": ""The response contains an active GraphQL introspection result (the __schema object and built-in introspection types such as __Type and __Schema). This indicates that schema introspection is enabled and returning type metadata. Exposed schema information allows attackers to enumerate types, queries, fields, and input shapes, increasing the attack surface and making it easier to craft targeted queries or exploit other vulnerabilities (e.g., data-exposing fields). Mitigation options include disabling introspection in production, enforcing authentication/authorization for introspection queries, applying query whitelisting, and implementing rate limiting and complexity/depth limits to reduce abuse.""}}]"
